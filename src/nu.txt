1.p51
2.p52 exercice11
3.p105 第一段代码以及thinkingInJava中chapter5中的Test26-Test29
4.p123第一段在jdk1.8下测试与原文不符
5.关于对象属性初始化
6、单处理器上使用并发（多线程）的开销要比使用单线程的开销大，如果不考虑阻塞问题，单处理器上没有必要用多线程     这是p651中间一段的描述：使这个问题变得有些不同的是阻塞。。。段尾，为什么？是因为上一段说的线程切换有开销吗？
7.清理对象时，最好使用自己编写的清理方法（比如dispose），不要使用finalize()，finalize()不确定会不会被调用以及什么时候会被调用，why？
8.构造方法里面调用多太方法，为什么会执行子类覆盖的方法而非父类的方法，参考《构造器内部多态方法的行为研究》看能不能找到答案
9.有关枚举的继承和实现
10.设计模式：适配器模式 、工厂模式、代理模式、策略模式、空迭代器模式 、命令模式
11.p185 看完内部类之后再看9.8
12.看完第13章回过头再来看p181 9.6和后面的练习16
13.p191练习1上面一句话与实际测试不符，测试代码为com.asiainfo.chapter10.Test1
14.com.asiainfo.chapter10.Test2  why?
15.优先使用类而不是接口 p201练习16上面一句话 why?
16.抽象类有构造器但是不能实例化
17.foreach的原理
18.Random与Math.random()
19.解释com.asiainfo.chapter11.Test22抛异常的原因。可参考课本p226练习7以及The_Thinking_in_Java_Annotated_Solution_Guide(TIJ4-solutions)p187
20.foreach的原理是迭代器，可参考http://blog.csdn.net/a596620989/article/details/6930479
21.com.asiainfo.chapter11.Test26对于LinkedHashMap测试结果的顺序貌似不正确
22、优先级队列在添加元素的时候会排序，但是添加完元素之后直接打印优先级队列并没有排序，why？
23、栈是后进先出，直接打印栈或者用get()的方式打印，元素输出顺序貌似不符合后进先出，详见Test69
24、System.out与System.err，可以参考com.asiainfo.chapter12.Test5
25、看一下p261代码是干什么的，当时没怎么看
26、父类构造器里面调用子类构造器，初始化顺序
27、为什么要区分受检异常和运行时异常，运行时异常为什么不强制处理
28、p276 12.12 其他可选方式  想要表达什么意思？对于受检异常在编译时强制进行处理的机制会流于形式化？强制程序员去处理他不会处理的异常，会逼程序员编写欺骗编译器的代码从而既不用处理异常也能编译通过？java没有强制去try/catch啊，不会处理可以throw出去啊，为什么要把受检异常转换成运行时异常，然后在调用方法里面再把它拆开？？？
29、如何解释com.asiainfo.chapter13.Test2
30、再循环里面String拼接操作的效率要小于StringBuilder的append()方法的效率，不在循环下呢？
31、com.asiainfo.chapter13.Test7第31行打印结果为什么会是乱码？
32、查看String的compareTo()方法的源码，其中offset是什么？
33、如何解释com.asiainfo.chapter13.Test8，为什么String是不可变的，通过javap -c能看出来吗？   就是p289第一段：从这个表可以看出
34、String的intern()方法
35、转义符与正则表达式，p296第一段什么意思，为什么是四个\，1~4个\分别代表什么意思  可参考Pattern的jdk api
36、p296中间(-|\\+)?为什么可以表示两者都没有
37、p299 13.6.3没看懂
38、偏移量和索引的关系
39、p302 A(B(C))D的解释，那(AB)(CD)(EF(G))哪个组号是0、1、2？
40、静态类和普通类的区别
41、p303代码后一部分打印结果（在p304）解释不通，主要是lookingAt()和matches()方法的问题，同样的问题还有Test28
42、p307 13.6.7上面的$g未测试，可参考jdk api
43、p308代码测不通，怎么读取当前文件啊？详见Exercise_15，运行Exercise_15程序会退出     练习15-19都没看懂答案
44、异常层次结构图画上
45、Class的getName()和getCanonicalName()的区别，详见api  Test3
46、p318练习6没有做
47、p315 SweetShop.java 中Class.forName()方法的参数如果不传入类的全名称就会抛异常，书里面的Class.forName("Gum");可以运行？
48、14.2.1前两段勾上  p319第一句话
49、p320 第二段是什么意思
50、p321第一段没看懂，为什么Class<?>优于Class，二者有什么区别？  如何解释Test16.met2()和Test16.met3()？
51、p331练习12没有做
52、什么是协变返回类型      泛型T和?有什么区别
53、p331 14.4下面的代码貌似没有解决开始描述的问题：要新加一个Part或一个Factory不照样要在基类Part的partFactories里面手工添加一下吗？
54、如何理解p333练习14第一句话：构造器就是一种工厂方法
55、p333练习16没有做
56、Test30运行结果为什么会有met5()？
57、14.7动态代理   没看懂   练习21-23没有做  p345代码没有看，因为涉及14.7内容——动态代理 测试p345代码的时候连同p344和p343下面的代码（Operation.java）一同测试   练习24也涉及动态代理
58、构造器里面调用了本类非静态方法，那么初始化的顺序是什么样的？见p342倒数第二行代码
59、p349最下面的代码——反射可以访问private域，测试结果不符——通过反射可以修改final值，见Test42
60、p656练习2、4、5  p669练习 10没有做，涉及到第15章的内容
61、p660 21.2.6第二段：试图操纵线程的优先级通常是一种错误，why？
62、p665练习8没有做
63、为什么p665 21.2.9打印结果显示出来的线程是顺序执行的？
64、类初始化顺序复习一下
65、p666  SelfManaged.java以及下面两段的描述没看懂——为什么在构造器中start线程会不安全？将线程类作为内部类或匿名内部类，然后再构造器启动线程就安全了吗？why？
66、什么场景适合使用内部类包括匿名内部类，使用（匿名）内部类有哪些好处？
67、为什么不能用try/catch捕获线程中run()方法抛出的异常
68、Test49怎么解释
69、Test54怎么解释打印结果：为什么t2释放锁后t3无法获得锁？Test61又该怎么解释？
70、volatile、synchronized的原理，比如把写操作写到主存，递增操作无法受该关键字保护等
71、javap -c 老提示找不到类，见Test63
72、p681 i += 2;怎么证明i += 2;不是原子性的
73、p681第七段第一句话：使用volatile而不是synchronized的唯一安全情况是类中只有一个可变的域。这句话是什么意思，为什么只有一个可变域才安全？
74、p682汇编代码下面一段的解释和Test64注释里网址链接的解释不太一样：书上说在获取和放置之间另一个线程会修改值，但是注释里的网址上说获取之后会把这个值放到自己的线程栈里面，其它线程怎么会干预?
75、p685练习14 见Exercise_14，熟悉一下Timer和TimerTask，为什么Exercise_14会一直运行？TimerTask的run()方法运行完不返回吗？
76、P688第二段没看懂，结合前面的代码，为什么PairManager要有一个唯一的public方法getPair()？为什么要弄个副本出来？这个方法是必须的吗？
77、了解一下 Collections.synchronizedList()方法
78、Test76  如果一个线程锁住了当前对象this，那么为什么另一个对象可以访问锁住this.o的方法呢？o不是this的一部分吗？
79、ExecutorService的shutdown()和shutdownNow()有什么区别？见Test68
80、volatile的原理是什么，有什么应用场景？
81、com.asiainfo.chapter15.exercise.Exercise_4 current()方法为什么要转型？
82、工厂模式
83、访问控制权限复习一下，接口在定义时不加访问控制权限，它默认是public的还是default访问权限？四种访问控制权限那些能修饰类？接口里面能有内部类吗
84、为什么构造器定义时不能有类型参数？比如 public Test1<T>() {}
85、为什么将泛型方法的返回值直接作为另一个方法的入參，编译器不会进行参数推断？
86、值传递、引用传递
87、为什么向下转型为泛型的时候会有警告，怎么用擦除解释？见Test48
88、对擦除的深入理解，到底什么是擦除？见Test49   p377 15.7.4没看懂   Test61怎么理解？
89、第15章Test57怎么解释？
90、p384第一段怎么理解？
91、p386最上面的代码没看懂，为什么Array.newInstance()可以从擦除中恢复？为什么Integer[] ia = gai.rep();可以成功？









underline:
p650第四段括上，勾上其中两句话：1、第二句：这可能会以一种。。。  2、最后一句       最后一段括上
21.1.1上面一句话    中间一段：但是，并发通常是提高。。。   下面一段：这听起来有些违背直觉。。。段尾  再下一段：使这个问题变得有些不同的是阻塞。。。段尾
p652第二段   倒数第四段：更重要的是。。。句末   倒数第二段全段
21.1.2第一段
p653第四段：java的线程机制是抢占式的。。。驱动它的任务
21.2第一段、第二段勾上  p653下面的注释
21.2.1下面第一段，还有下面的第三、四段     在21.2.1的代码旁边写上Test1的注释
p655第一段  21.2.2下面第一句   下面第二段：Thread构造器只需要一个。。。启动该任务   括号里面：这种能力不局限于    21.2.2下面第一段代码旁边写上：建立线程实例不一定在线程类里面，所以线程的启动也不一定在线程类里面，本例BasicThreads类不是一个线程类（没有直接或间接地实现Runnable接口，他的直接父类就是Object），是一个普通类      本页最后一段
p656第二段第一句话
p657上面写上Test4的注释   第1、2、3段勾上   下面的“注意，”那句话勾上    4-6段括起来
p658 SingleThreadExecutor示例的旁边写上：表面上看是创建了5个线程，但这5个线程在Executor里面是按照创建顺序排队运行的，换句话说就是这5个线程在Executor里面是同步的，所以本例相当于两个线程——一个是主线程，一个是SingleThreadExecutor里面的的那个“单例”线程
21.2.4示例代码旁边写上：Callable和Runnable类似，它只有一个抽象方法call()，该方法具有返回值。通过ExecutorService调用submit()方法后，会自动调用Callable实现类的call()方法，submit()方法返回Future，通过Future的get()方法获取call()方法的返回值
p661倒数第三段最后一句话，什么叫计算任务繁重的时候，线程调度机制才来得及介入并关注优先级？执行的任务不繁重的时候不是这样吗？线程切换不就是靠线程调度器来调度的吗？什么叫任务繁重的时候才来的及调度？将Test11的run()方法里面放入for循环注掉为什么不是优先级较高的来运行？
p671第一段旁边写上：详见Test31和Test32，在第四行旁边写上一句话：interrupt()方法只是将线程的中断状态改成true而不是实际去中断线程，如果该线程在运行中不去检查这个状态，那么线程将继续运行
21.2.13线程组旁边写上：线程组没什么用
p674上面代码旁边写上：UncaughtExceptionHandler是Thread类的一个内部接口，而defaultUncaughtExceptionHandler是Thread类的一个静态属性           在21.3上面做后一段旁边写上：见Test42
p675中间一段：“例如，一个任务不能依赖于另一个任务”这句话勾上
p676第二段对后一句话：这只是并发程序的部分问题...
21.3.2下面第一段的第一句话和最后一句话     第二段第一句话   第三段勾上
p677第一段画上重点  第二段勾上   第三段最后一句话   第5段-本页最后画上大括号加重点符号     synchronized void f(){}旁边写上：锁住的是调用当前方法的对象（this）
p677在第五段旁边写上：见Test46、47、48
p679第一、二段没看懂：线程抛异常退出可能会没有执行清理工作，但这跟在finally{}里面释放锁有什么关系，详见Test52、Test53   第一段旁边写上：见Test57，有关java Lock可详见Test57注释的地址
p358 15.3下面两段
p352第二段下面写上：interface默认是abstract的，所以再定义接口时，interface和abstract interface是一样的，而且接口里面可以有内部类和内部接口，见Test5。设计接口的目的就是被实现的，所以接口不能被final修饰
p353第二段有关边界的勾上 15.2下面第一句话 最后一段勾上
p354第三段、第四段勾上，在第三段旁边写上：如果在使用
参数类型推断旁边写上：参数类型推断只在赋值的时候体现出来，是通过接收方法返回值的变量的类型来推断该方法内泛型的具体类型
p367第一段最后一句话旁边写上：见Exercise_15
15.8下面第一句话
p380下面代码空白处写上：Class的isInstance()方法与关键字instanceof等效，只不过方向相反：instanceof表达的意思是：左边的对象是不是右边类型的一个实例；isInstance()方法可以理解为：右边的对象是不是左边类型的一个实例。见Test50
