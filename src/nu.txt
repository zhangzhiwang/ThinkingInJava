1.p51
2.p52 exercice11
3.p105 第一段代码以及thinkingInJava中chapter5中的Test26-Test29
4.p123第一段在jdk1.8下测试与原文不符
5.关于对象属性初始化
7.清理对象时，最好使用自己编写的清理方法（比如dispose），不要使用finalize()，finalize()不确定会不会被调用以及什么时候会被调用，why？
8.构造方法里面调用多太方法，为什么会执行子类覆盖的方法而非父类的方法，参考《构造器内部多态方法的行为研究》看能不能找到答案
9.有关枚举的继承和实现
10.适配器模式
11.p185 看完内部类之后再看9.8
12.看完第13章回过头再来看p181 9.6和后面的练习16
13.p191练习1上面一句话与实际测试不符，测试代码为com.asiainfo.chapter10.Test1
14.com.asiainfo.chapter10.Test2  why?
15.优先使用类而不是接口 p201练习16上面一句话 why?
16.抽象类有构造器但是不能实例化
17.foreach的原理
18.Random与Math.random()
19.解释com.asiainfo.chapter11.Test22抛异常的原因。可参考课本p226练习7以及The_Thinking_in_Java_Annotated_Solution_Guide(TIJ4-solutions)p187
20.foreach的原理是迭代器，可参考http://blog.csdn.net/a596620989/article/details/6930479
21.com.asiainfo.chapter11.Test26对于LinkedHashMap测试结果的顺序貌似不正确
22、优先级队列在添加元素的时候会排序，但是添加完元素之后直接打印优先级队列并没有排序，why？
23、栈是后进先出，直接打印栈或者用get()的方式打印，元素输出顺序貌似不符合后进先出，详见Test69
24、System.out与System.err，可以参考com.asiainfo.chapter12.Test5
25、看一下p261代码是干什么的，当时没怎么看
26、父类构造器里面调用子类构造器，初始化顺序
27、为什么要区分受检异常和运行时异常，运行时异常为什么不强制处理
28、p276 12.12 其他可选方式  想要表达什么意思？对于受检异常在编译时强制进行处理的机制会流于形式化？强制程序员去处理他不会处理的异常，会逼程序员编写欺骗编译器的代码从而既不用处理异常也能编译通过？java没有强制去try/catch啊，不会处理可以throw出去啊，为什么要把受检异常转换成运行时异常，然后在调用方法里面再把它拆开？？？
29、如何解释com.asiainfo.chapter13.Test2
30、再循环里面String拼接操作的效率要小于StringBuilder的append()方法的效率，不在循环下呢？
31、com.asiainfo.chapter13.Test7第31行打印结果为什么会是乱码？
32、查看String的compareTo()方法的源码，其中offset是什么？
33、如何解释com.asiainfo.chapter13.Test8，为什么String是不可变的，通过javap -c能看出来吗？   就是p289第一段：从这个表可以看出
34、String的intern()方法
35、转义符与正则表达式，p296第一段什么意思，为什么是四个\，1~4个\分别代表什么意思  可参考Pattern的jdk api
36、p296中间(-|\\+)?为什么可以表示两者都没有
37、p299 13.6.3没看懂
38、偏移量和索引的关系
39、p302 A(B(C))D的解释，那(AB)(CD)(EF(G))哪个组号是0、1、2？
40、静态类和普通类的区别
41、p303代码后一部分打印结果（在p304）解释不通，主要是lookingAt()和matches()方法的问题，同样的问题还有Test28
42、p307 13.6.7上面的$g未测试，可参考jdk api
43、p308代码测不通，怎么读取当前文件啊？详见Exercise_15，运行Exercise_15程序会退出     练习15-19都没看懂答案
44、异常层次结构图画上
45、Class的getName()和getCanonicalName()的区别，详见api  Test3
46、p318练习6没有做
47、p315 SweetShop.java 中Class.forName()方法的参数如果不传入类的全名称就会抛异常，书里面的Class.forName("Gum");可以运行？
48、14.2.1前两段勾上  p319第一句话
49、p320 第二段是什么意思
50、p321第一段没看懂，为什么Class<?>优于Class




underline:
14.1上面一段 本章。。。  14.1下面第二段 这是一个。。。结尾  14.1标题旁边写上 RTTI：Run-Time Type Identification，通过运行时类型信息程序能够使用基类的指针或引用来检查这些指针或引用所指的对象的实际派生类型。
p314第一段中间 如果某个对象。。。的String  第三段 这是rtti最基本。。。段尾
p315第三段都勾上   第四段第一句话 第五段全勾上
p316第二段 Class对象。。。      这个方法是class类。。。加载它  下面一段  如果Class.forName()找不到。。那句话勾上  下一段 无论何时。。。类型的Class引用。在这段话旁边写上 详见Test2
p317最后一段
p320第二段旁边写上：所以，不能简单地认为第一次访问某类的静态常量不会导致该类的加载，要看常量值是不是字面量
14.2.2下面第一段
p321前三段
14.2.3下面第二段第一句话 cast()方法。。。
p323第三段 之所以叫向下转型。。。被称作向下转型        RTTI在java中海油第三种形式。。。     还有下面一段：再将x。。。